a
makeCacheMatrix(a)
makeCacheMatrix <- function (x = matrix(),...) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(num = 1:4 , ncol = 2, nrow = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a <- matrix(1:4,nrow=2,col=2)
a <- matrix(1:4,nrow=2,ncol=2)
a
solve(a)
makeCacheMatrix(a)
cacheSolve(a)
makeCacheMatrix <- function (x = matrix(),...) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(num = 1:4 , ncol = 2, nrow = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a
makeCacheMatrix(a)
cacheSolve(a)
makeCacheMatrix <- function (x = matrix(),...) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
makeCacheMatrix(a)
cacheSolve(a)
p <- 2
q <- function() x
q(3)
pakora <- 2
quora <- function() x
quora(3)
quora ()
pakora <- 2
quora <- function() pakora
quora(3)
quora()
pakora <- 2
quora <- function() {pakora}
quora()
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a <- makeCacheMatrix(1:4)
a
cacheSolve(a)
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a <- makeCacheMatrix(1:4)
cacheSolve(a)
cacheSolve(a)
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
makeCacheMatrix(1:4)
cacheSolve(a)
message("Retrieving cached inverse")
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
?message
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
cacheSolve(makeCacheMatrix(1:4))
?matrix
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
cacheSolve(makeCacheMatrix(1:4))
cacheSolve(makeCacheMatrix(1:4))
?trycatch
?tryCatch
?solve
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list <- list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function (x,...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
m <- rbind(c(1,-1/4),c(-1/4,1))
makeCacheMatrix(m)
f<- makeCacheMatrix(m)
cacheSolve(f)
version
getwd()
R.home()
Sys.getenv("PATH")
R.home()
Sys.getenv("PATH")
path.expand()
Sys.getenv()
Sys.getenv("MySQL_HOME")
install.packages('RMySQL', type = 'source')
library(MySQL)
Sys.getenv()
install.packages('RMySQL', type = 'source')
Sys.getenv()
?Sys.setenv
Sys.getenv()
Sys.getenv()
install.packages("RMySQL", type = "source")
library(RMySQL)
library("RMySQL")
Sys.getenv()
install.packages("RMySQL", type = "source")
library(RMySQL)
library(swirl)
swirl()
size_gb <- size_mb/2^10
View(cran2)
View(cran3)
mutate(cran3, size_mb = size/2^20, size_gb = size_mb/2^10)
View(cran3)
mutate(cran3, correct_size = size + 1000)
summarize(cran, avg_bytes = mean(size))
library(dplyr)
cran <- tbl_df(mydf)
rm("mydf")
cran
?group_by
by_package <- group_by(cran, "package")
by_package <- group_by(cran, package)
by_package
summarize(mean(size))
summarize(by_package, mean(size))
submit()
by_package
View(by_package)
View(by_package)
?n_distinct()
submit()
sumbit
submit
submit()
submit()
quit()
quit()
?connections
quit()
setwd("~/Coursera")
dir()
?formatC()
setwd("C:\Users\Dell\Documents\ISLR")
setwd("C://Users//Dell//Documents//ISLR")
getwd()
setwd("~/Coursera")
setwd("~/Documents")
setwd("C://Users//Dell//Documents")
mkdir("UMT")
?mkdir()
Library(MASS)
install.packages("MASS")
#This function is for Classification Methods LR,LDA,QDA and KNN.
#Loading Libraries
library(ISLR)
#Preparing Dataset
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
#Creating Correlation matrix and identifying highly correlated variables
Smarket_cor <- cor(Smarket[,-9])
sort(Smarket_cor, decreasing = T)
which(Smarket_cor > 0.5 & Smarket_cor < 1, arr.ind = T)
colnames(Smarket_cor)[c(1,7)]
#Observing the highly correlated variables
plot(Smarket$Volume, col = "dark grey", pch = 4)
print("Volume appears to increase with time")
#Running Logistic Regression on the Dataset
glm.fit <- glm(Direction ~. -Year -Today, data = Smarket, family = binomial)
summary(glm.fit)
summary(glm.fit)$coefs
summary(glm.fit)$coef
names(summary(glm.fit))
summary(glm.fit)$coefficients
summary(glm.fit)$contrasts
contrasts(summary(glm.fit))
summary(glm.fit)
summary(glm.fit)$coefficients[,4]
summary(glm.fit)$coefficients[4,]
summary(glm.fit)$coefficients
contrasts(Direction)
contrasts(Smarket$Direction)
attach(Smarket)
?predict()
glm.fit_probs <- predict(glm.fit, type = "response")
glm.fit_probs[1:10]
predict(glm.fit)[1:10]
.rs.restartR()
library(MASS)
search()
.rs.restartR()
search()
q()
getwd()
?read.csv
y <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/y_test.txt)
y <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/y_test.txt")
y
dim(y)
y <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/y_test.txt", sep = "", header = F)
dim(y)
y[1:10]
y[1:10,]
str(y)
y <- as.factor(y)
y[,1] <- as.factor(y[,1])
str(y)
X <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/X_test.txt")
X[1:5,1:5]
dim(X)
X[1:5,1
]
X[1,1]
X <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/X_test.txt", sep = "")
X[1,1]
head(X)
X <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/X_test.txt", sep = "", header = F)
dim(X)
X <- read.csv("~/Coursera/HARdata/UCI HAR Dataset/test/subject_test.txt", sep = "", header = F)
dim(X)
?read.table
?data.table
>read.table
read.table
?read.table
args(read.table)
library(ISLR)
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
Smarket_cor <- cor(Smarket[,-9])
attach(Smarket)
glm.fit <- glm(Direction ~. -Year -Today, data = Smarket, family = binomial)
summary(glm.fit)
glm.fit <- glm(Direction ~ Lag1 + Lag2, data = Smarket, family = binomial)
summary(glm.fit)
glm.fit <- glm(Direction ~ Lag1, data = Smarket, family = binomial)
summary(glm.fit)
kk <- c(140, 160, 145, 155, 160, 165, 140, 135, 138, 162)
sum(kk)
length(kk)
150
k1 <- kk
rm(kk)
k2 <- c(142, 161, 149, 156, 160, 165, 145, 137, 139, 161)
sum(k2)
151.5-150
k3 <- c(148, 152, 151, 149, 151, 153, 149, 147, 149, 151)
sum(k3)
k4 <- c(150, 153, 151, 148, 152, 152, 153, 151, 149, 150)
k <- as.list(k1,k2,k3,k4)
k
?list
k <- list(k1,k2,k3,k4)
k
var <- data.frame
var <- data.frame(NULL)
var <- numeric()
var <- numeric()
for (i in 1:4){
var[i] = sum(k[[i]])/length(k[[i]])
}
var
variance <- sum(var)/4
variance
variance <- sum(var - 150)/4
variance
mean(k1)
setwd("~/UMT")
setwd("Datascience")
Setwd("Midterm")
setwd("Midterm")
setwd("Solution")
dir()
Polls <- read.csv("PollingData_Imputed.csv")
dim(Polls)
str(Polls)
Polls$Year <- as.factor(Polls$Year)
Polls$Republican <- as.factor(Polls$Republican)
summary(Polls$State)
Tree1 <- tree(Republican ~. ,  data = Polls2)
library(tree)
Tree1 <- tree(Republican ~. ,  data = Polls2)
plot(Tree1)
Polls2 <- Polls[2:7]
library(tree)
Tree1 <- tree(Republican ~. ,  data = Polls2)
plot(Tree1)
text(Tree1, cex = 0.6)
CV_Tree1 <- cv.tree(Tree1, FUN = prune.misclass)
cbind(size = CV_Tree1$size, par =  CV_Tree1$k, err = CV_Tree1$dev)
Tree2 <- prune.misclass(Tree1, best = 2)
plot(Tree2)
text(Tree2)
library(rpart)
Tree3 <- rpart(Republican ~. ,  data = Polls2)
plot(Tree3)
text(Tree3, cex = 0.8)
Tree3$cptable
